// ═══════════════════════════════════════════════════════════
// CJHIRASHI Agents - Database Schema v2.0
// Sistema de Asistente Personal de IA
// ═══════════════════════════════════════════════════════════

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ═══════════════════════════════════════════════════════════
// SISTEMA DE USUARIOS Y AUTENTICACIÓN
// ═══════════════════════════════════════════════════════════

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  emailVerified     DateTime?

  // Información básica
  name              String?
  displayName       String?   // Nombre preferido por el usuario
  avatar            String?
  dateOfBirth       DateTime?
  timezone          String    @default("America/Mexico_City")
  language          String    @default("es")
  bio               String?   @db.Text

  // Sistema de roles y permisos
  role              UserRole  @default(USER)
  permissions       Json?     // Permisos personalizados granulares
  isActive          Boolean   @default(true)

  // Perfil de personalidad generado por IA
  personalityProfile Json?    // Ver estructura en documentación
  aiProfileLastUpdate DateTime?

  // Sistema de suscripciones
  subscriptionTier  SubscriptionTier @default(FREE)
  subscriptionId    String?   // ID externo (Stripe, etc)
  subscriptionStart DateTime?
  subscriptionEnd   DateTime?
  customLimits      Json?     // Límites personalizados por super admin

  // Métricas de uso
  totalMessages     Int       @default(0)
  totalTokensUsed   BigInt    @default(0)
  monthlyMessages   Int       @default(0)
  monthlyTokens     BigInt    @default(0)
  lastResetAt       DateTime  @default(now())
  lastInteraction   DateTime?

  // Relaciones de autenticación
  accounts          Account[]
  authSessions      Session[]

  // Relaciones de sistema
  createdAgents     Agent[]              @relation("CreatedAgents")
  agentPermissions  UserAgentPermission[]
  chatSessions      ChatSession[]

  // Relaciones de perfil
  healthProfile     HealthProfile?
  financialProfile  FinancialProfile?

  // Relaciones de uso y auditoría
  usageLogs         UsageLog[]
  monthlyUsage      MonthlyUsage[]
  usageAlerts       UsageAlert[]
  invitationsSent   Invitation[]         @relation("InvitationsSent")
  invitationsReceived Invitation[]       @relation("InvitationsReceived")
  auditLogs         AuditLog[]

  // Relaciones de soporte
  supportTickets    SupportTicket[]      @relation("UserTickets")
  assignedTickets   SupportTicket[]      @relation("AssignedTickets")

  // Relaciones de RAG (Phase 6)
  documents         Document[]

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("users")
}

enum UserRole {
  // Administración
  SUPER_ADMIN       // Control total - Solo cjhirashi@gmail.com
  ADMIN             // Gestión de usuarios y permisos

  // Usuarios por Invitación
  INVITED_AGENT     // Usuario invitado - Acceso a agentes específicos asignados por admin
  INVITED_STORAGE   // Usuario invitado con acceso a Storage - Guests del sistema

  // Usuarios por Suscripción
  SUBSCRIBER        // Usuario que se suscribe a un plan de renta

  // Otros (futuro)
  MANAGER           // Supervisión y reportes (futuro)
  DEVELOPER         // Crear y gestionar agentes (futuro)
  USER              // Usuario estándar
  GUEST             // Acceso limitado (futuro)
}

enum SubscriptionTier {
  FREE           // Límites básicos
  BASIC          // Plan entrada
  PRO            // Plan profesional
  ENTERPRISE     // Plan empresarial
  CUSTOM         // Plan personalizado por super admin
  UNLIMITED      // Sin límites (para usuarios especiales)
}

// Tabla de autenticación OAuth
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// Sesiones de autenticación
model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("auth_sessions")
}

// Tokens de verificación
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Sistema de invitaciones
model Invitation {
  id          String           @id @default(uuid())
  email       String
  token       String           @unique
  role        UserRole
  status      InvitationStatus @default(PENDING)
  invitedBy   String           // User ID del admin que invitó
  expiresAt   DateTime
  acceptedAt  DateTime?

  inviter     User             @relation("InvitationsSent", fields: [invitedBy], references: [id], onDelete: Cascade)
  invitee     User?            @relation("InvitationsReceived", fields: [email], references: [email])

  createdAt   DateTime         @default(now())

  @@index([email])
  @@index([invitedBy])
  @@map("invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// ═══════════════════════════════════════════════════════════
// SISTEMA DE SALUD
// ═══════════════════════════════════════════════════════════

model HealthProfile {
  id                String    @id @default(uuid())
  userId            String    @unique

  // Información básica
  bloodType         String?
  height            Decimal?  // cm
  weight            Decimal?  // kg
  sex               String?

  // Contactos de emergencia (JSON encriptado)
  emergencyContacts Json?

  // Información de seguros
  insuranceInfo     Json?

  // Datos altamente sensibles (encriptados)
  encryptedData     String?   @db.Text

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  conditions        MedicalCondition[]
  medications       Medication[]
  allergies         Allergy[]
  appointments      MedicalAppointment[]
  measurements      HealthMeasurement[]

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("health_profiles")
}

model MedicalCondition {
  id                String    @id @default(uuid())
  healthProfileId   String

  name              String
  type              String    // "crónica", "aguda", "genética"
  severity          String    // "leve", "moderada", "severa"
  diagnosedDate     DateTime?
  diagnosedBy       String?
  status            String    @default("activa")

  notes             String?   @db.Text
  treatment         Json?

  healthProfile     HealthProfile @relation(fields: [healthProfileId], references: [id], onDelete: Cascade)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([healthProfileId])
  @@map("medical_conditions")
}

model Medication {
  id                String    @id @default(uuid())
  healthProfileId   String

  name              String
  genericName       String?
  dosage            String
  frequency         String
  route             String

  prescribedBy      String?
  prescribedDate    DateTime?
  startDate         DateTime
  endDate           DateTime?

  purpose           String?
  sideEffects       String?   @db.Text
  interactions      Json?

  // Sistema de recordatorios
  reminderEnabled   Boolean   @default(false)
  reminderTimes     Json?

  isActive          Boolean   @default(true)
  notes             String?   @db.Text

  healthProfile     HealthProfile @relation(fields: [healthProfileId], references: [id], onDelete: Cascade)
  adherenceLogs     MedicationLog[]

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([healthProfileId])
  @@index([isActive])
  @@map("medications")
}

model MedicationLog {
  id              String     @id @default(uuid())
  medicationId    String
  scheduledTime   DateTime
  takenTime       DateTime?
  status          String     // "tomado", "omitido", "retrasado"
  notes           String?

  medication      Medication @relation(fields: [medicationId], references: [id], onDelete: Cascade)
  createdAt       DateTime   @default(now())

  @@index([medicationId, scheduledTime])
  @@map("medication_logs")
}

model Allergy {
  id                String    @id @default(uuid())
  healthProfileId   String

  allergen          String
  type              String    // "medicamento", "alimento", "ambiental"
  severity          String    // "leve", "moderada", "severa", "anafiláctica"
  reaction          String?   @db.Text
  diagnosedDate     DateTime?

  notes             String?   @db.Text

  healthProfile     HealthProfile @relation(fields: [healthProfileId], references: [id], onDelete: Cascade)
  createdAt         DateTime  @default(now())

  @@index([healthProfileId])
  @@map("allergies")
}

model MedicalAppointment {
  id                String    @id @default(uuid())
  healthProfileId   String

  type              String
  specialty         String?
  doctorName        String?
  facility          String?

  scheduledDate     DateTime
  duration          Int?      // minutos

  status            String    @default("programada")
  reason            String?   @db.Text
  notes             String?   @db.Text
  results           String?   @db.Text

  // Recordatorios
  reminderSent      Boolean   @default(false)
  reminderTime      DateTime?

  healthProfile     HealthProfile @relation(fields: [healthProfileId], references: [id], onDelete: Cascade)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([healthProfileId, scheduledDate])
  @@map("medical_appointments")
}

model HealthMeasurement {
  id                String    @id @default(uuid())
  healthProfileId   String

  type              String    // "weight", "blood_pressure", "glucose", etc.
  value             Json      // Estructura flexible
  measuredAt        DateTime  @default(now())
  notes             String?

  healthProfile     HealthProfile @relation(fields: [healthProfileId], references: [id], onDelete: Cascade)

  @@index([healthProfileId, type, measuredAt])
  @@map("health_measurements")
}

// ═══════════════════════════════════════════════════════════
// SISTEMA FINANCIERO
// ═══════════════════════════════════════════════════════════

model FinancialProfile {
  id                String    @id @default(uuid())
  userId            String    @unique

  currency          String    @default("MXN")
  fiscalYear        String    @default("calendar")

  // Metas financieras
  financialGoals    Json?

  // Análisis generado por IA
  aiAnalysis        Json?

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accounts          FinancialAccount[]
  transactions      Transaction[]
  budgets           Budget[]
  debts             Debt[]
  investments       Investment[]
  recurringPayments RecurringPayment[]

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("financial_profiles")
}

model FinancialAccount {
  id                  String    @id @default(uuid())
  financialProfileId  String

  name                String
  type                String    // "checking", "savings", "credit", "investment"
  institution         String?

  balance             Decimal   @db.Decimal(15, 2)
  currency            String    @default("MXN")

  lastSyncDate        DateTime?
  isActive            Boolean   @default(true)

  // Para tarjetas de crédito
  creditLimit         Decimal?  @db.Decimal(15, 2)
  availableCredit     Decimal?  @db.Decimal(15, 2)
  closingDate         Int?
  paymentDueDate      Int?

  notes               String?   @db.Text

  financialProfile    FinancialProfile @relation(fields: [financialProfileId], references: [id], onDelete: Cascade)
  transactions        Transaction[]

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([financialProfileId])
  @@map("financial_accounts")
}

model Transaction {
  id                  String    @id @default(uuid())
  financialProfileId  String
  accountId           String?

  date                DateTime
  description         String
  amount              Decimal   @db.Decimal(15, 2)
  type                String    // "income", "expense", "transfer"

  category            String
  subcategory         String?
  tags                Json?

  // Para transferencias
  fromAccountId       String?
  toAccountId         String?

  isRecurring         Boolean   @default(false)
  recurringPaymentId  String?

  notes               String?   @db.Text
  receipt             String?   // URL

  financialProfile    FinancialProfile @relation(fields: [financialProfileId], references: [id], onDelete: Cascade)
  account             FinancialAccount? @relation(fields: [accountId], references: [id], onDelete: SetNull)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([financialProfileId, date])
  @@index([category, date])
  @@map("transactions")
}

model Budget {
  id                  String    @id @default(uuid())
  financialProfileId  String

  name                String
  category            String
  amount              Decimal   @db.Decimal(15, 2)
  period              String    @default("monthly")

  startDate           DateTime
  endDate             DateTime?

  alertThreshold      Int       @default(80)
  alertSent           Boolean   @default(false)

  isActive            Boolean   @default(true)

  financialProfile    FinancialProfile @relation(fields: [financialProfileId], references: [id], onDelete: Cascade)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([financialProfileId])
  @@map("budgets")
}

model Debt {
  id                  String    @id @default(uuid())
  financialProfileId  String

  name                String
  type                String

  principal           Decimal   @db.Decimal(15, 2)
  balance             Decimal   @db.Decimal(15, 2)
  interestRate        Decimal   @db.Decimal(5, 2)

  monthlyPayment      Decimal   @db.Decimal(15, 2)
  minimumPayment      Decimal?  @db.Decimal(15, 2)

  startDate           DateTime
  maturityDate        DateTime?
  paymentDueDay       Int

  creditor            String
  accountNumber       String?

  status              String    @default("active")
  payoffStrategy      String?
  priority            Int       @default(1)

  notes               String?   @db.Text

  financialProfile    FinancialProfile @relation(fields: [financialProfileId], references: [id], onDelete: Cascade)
  payments            DebtPayment[]

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([financialProfileId])
  @@map("debts")
}

model DebtPayment {
  id                String    @id @default(uuid())
  debtId            String

  date              DateTime
  amount            Decimal   @db.Decimal(15, 2)
  principalPaid     Decimal   @db.Decimal(15, 2)
  interestPaid      Decimal   @db.Decimal(15, 2)

  notes             String?

  debt              Debt      @relation(fields: [debtId], references: [id], onDelete: Cascade)
  createdAt         DateTime  @default(now())

  @@index([debtId, date])
  @@map("debt_payments")
}

model Investment {
  id                  String    @id @default(uuid())
  financialProfileId  String

  name                String
  type                String
  symbol              String?

  quantity            Decimal?  @db.Decimal(20, 8)
  purchasePrice       Decimal   @db.Decimal(15, 2)
  currentPrice        Decimal?  @db.Decimal(15, 2)
  currentValue        Decimal?  @db.Decimal(15, 2)

  purchaseDate        DateTime
  platform            String?

  returns             Decimal?  @db.Decimal(15, 2)
  returnsPercentage   Decimal?  @db.Decimal(5, 2)

  notes               String?   @db.Text

  financialProfile    FinancialProfile @relation(fields: [financialProfileId], references: [id], onDelete: Cascade)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([financialProfileId])
  @@map("investments")
}

model RecurringPayment {
  id                  String    @id @default(uuid())
  financialProfileId  String

  name                String
  amount              Decimal   @db.Decimal(15, 2)
  frequency           String
  category            String

  nextDueDate         DateTime
  dayOfMonth          Int?
  dayOfWeek           Int?

  autoDebit           Boolean   @default(false)
  accountId           String?

  startDate           DateTime
  endDate             DateTime?

  isActive            Boolean   @default(true)
  reminderEnabled     Boolean   @default(true)
  reminderDaysBefore  Int       @default(3)

  notes               String?   @db.Text

  financialProfile    FinancialProfile @relation(fields: [financialProfileId], references: [id], onDelete: Cascade)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([financialProfileId, nextDueDate])
  @@map("recurring_payments")
}

// ═══════════════════════════════════════════════════════════
// SISTEMA DE AGENTES
// ═══════════════════════════════════════════════════════════

model Agent {
  id              String                @id @default(uuid())
  createdBy       String

  name            String
  slug            String                @unique  // URL-friendly name
  description     String?               @db.Text
  category        String                // "personal", "productivity", "creative", etc.

  // Configuración técnica
  model           String                // "gemini-2.0-flash", etc.
  config          Json?                 // Configuración específica del agente
  endpointUrl     String
  systemPrompt    String?               @db.Text

  // Visibilidad y permisos
  isPublic        Boolean               @default(false)
  isActive        Boolean               @default(true)

  // Documentación del agente
  documentationUrl String?
  tutorialUrl      String?
  capabilities     Json?                // Lista de capacidades

  // Estadísticas
  totalUses       Int                   @default(0)
  totalMessages   Int                   @default(0)
  averageRating   Decimal?              @db.Decimal(3, 2)

  creator         User                  @relation("CreatedAgents", fields: [createdBy], references: [id], onDelete: Cascade)
  conversations   Conversation[]
  userPermissions UserAgentPermission[]
  artifacts       Artifact[]
  usageLogs       UsageLog[]

  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  @@index([createdBy])
  @@index([slug])
  @@index([category])
  @@map("agents")
}

model Conversation {
  id            String      @id @default(uuid())
  chatSessionId String
  agentId       String

  title         String
  summary       String?     @db.Text

  // Metadata
  messageCount  Int         @default(0)
  tokenCount    Int         @default(0)

  agent         Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)
  chatSession   ChatSession @relation(fields: [chatSessionId], references: [id], onDelete: Cascade)
  messages      Message[]

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([agentId])
  @@index([chatSessionId])
  @@map("conversations")
}

model Message {
  id             String       @id @default(uuid())
  conversationId String

  role           String       // 'user' | 'assistant' | 'system'
  content        String       @db.Text

  // Métricas
  tokensInput    Int?
  tokensOutput   Int?

  // Metadata
  metadata       Json?
  timestamp      DateTime     @default(now())

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("messages")
}

model ChatSession {
  id            String         @id @default(uuid())
  userId        String

  startedAt     DateTime       @default(now())
  lastActivity  DateTime       @updatedAt
  metadata      Json?

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversations Conversation[]

  @@index([userId])
  @@map("chat_sessions")
}

model UserAgentPermission {
  id        String   @id @default(uuid())
  userId    String
  agentId   String
  grantedBy String?
  grantedAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  agent     Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@unique([userId, agentId])
  @@index([userId])
  @@index([agentId])
  @@map("user_agent_permissions")
}

// Sistema de artefactos con versionamiento
model Artifact {
  id              String    @id @default(uuid())
  agentId         String
  userId          String
  conversationId  String?

  name            String
  type            String    // "code", "document", "image", "data"
  content         String    @db.Text

  // Versionamiento
  version         Int       @default(1)
  parentId        String?   // ID del artefacto padre (para versiones)

  // Metadata
  metadata        Json?
  tags            Json?

  agent           Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  parent          Artifact? @relation("ArtifactVersions", fields: [parentId], references: [id])
  versions        Artifact[] @relation("ArtifactVersions")

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([agentId])
  @@index([userId])
  @@index([parentId])
  @@map("artifacts")
}

// ═══════════════════════════════════════════════════════════
// SISTEMA DE MÉTRICAS Y AUDITORÍA
// ═══════════════════════════════════════════════════════════

model UsageLog {
  id                String    @id @default(uuid())
  userId            String
  agentId           String
  conversationId    String?
  messageId         String?

  // Métricas de uso
  tokensInput       Int
  tokensOutput      Int
  totalTokens       Int
  model             String

  // Costos
  costInput         Decimal   @db.Decimal(10, 6)
  costOutput        Decimal   @db.Decimal(10, 6)
  totalCost         Decimal   @db.Decimal(10, 6)

  // Metadata
  duration          Int?      // milisegundos
  success           Boolean   @default(true)
  errorMessage      String?

  timestamp         DateTime  @default(now())

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  agent             Agent     @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([agentId, timestamp])
  @@map("usage_logs")
}

model MonthlyUsage {
  id                String    @id @default(uuid())
  userId            String
  year              Int
  month             Int

  // Totales
  totalMessages     Int
  totalTokens       BigInt
  totalCost         Decimal   @db.Decimal(10, 2)

  // Por agente
  agentUsage        Json

  // Límites del mes
  limitMessages     Int?
  limitTokens       BigInt?

  // Estado
  exceededLimit     Boolean   @default(false)
  warningsSent      Int       @default(0)

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([userId, year, month])
  @@index([userId])
  @@map("monthly_usage")
}

model UsageAlert {
  id                String    @id @default(uuid())
  userId            String
  type              AlertType
  threshold         Int       // Porcentaje
  triggered         Boolean   @default(false)
  resolvedAt        DateTime?

  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt         DateTime  @default(now())

  @@index([userId])
  @@map("usage_alerts")
}

enum AlertType {
  APPROACHING_LIMIT
  LIMIT_WARNING
  LIMIT_EXCEEDED
  UNUSUAL_ACTIVITY
}

model AuditLog {
  id          String   @id @default(uuid())
  adminId     String
  action      String   // "INVITE_USER", "DELETE_USER", "CHANGE_ROLE"
  targetId    String?
  details     Json?
  ipAddress   String?
  timestamp   DateTime @default(now())

  admin       User     @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([timestamp])
  @@map("audit_logs")
}

// ═══════════════════════════════════════════════════════════
// SISTEMA DE SOPORTE Y TICKETS
// ═══════════════════════════════════════════════════════════

// Tickets de soporte
model SupportTicket {
  id          String             @id @default(uuid())
  ticketNumber String            @unique // Formato: TICK-XXXXXX
  title       String
  description String             @db.Text
  category    TicketCategory
  priority    TicketPriority     @default(MEDIUM)
  status      TicketStatus       @default(OPEN)

  // Relaciones
  userId      String
  user        User               @relation("UserTickets", fields: [userId], references: [id], onDelete: Cascade)

  assignedToId String?
  assignedTo  User?              @relation("AssignedTickets", fields: [assignedToId], references: [id], onDelete: SetNull)

  messages    SupportMessage[]

  // IA
  aiSuggestion String?           @db.Text // Sugerencia inicial de la IA
  aiResolved  Boolean            @default(false) // Si la IA pudo resolver el problema

  // Metadata
  metadata    Json?              // Info adicional (browser, OS, etc)
  resolvedAt  DateTime?
  closedAt    DateTime?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([userId])
  @@index([assignedToId])
  @@index([status])
  @@index([ticketNumber])
  @@map("support_tickets")
}

// Mensajes del ticket (chat entre usuario y admin/IA)
model SupportMessage {
  id        String        @id @default(uuid())
  ticketId  String
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  content   String        @db.Text
  isStaff   Boolean       @default(false) // true = admin/staff, false = usuario
  isAI      Boolean       @default(false) // true = respuesta de IA
  authorId  String?       // null si es IA

  // Metadata
  attachments Json?       // URLs de archivos adjuntos
  createdAt DateTime      @default(now())

  @@index([ticketId])
  @@index([createdAt])
  @@map("support_messages")
}

enum TicketCategory {
  BUG           // Error en la aplicación
  FEATURE       // Solicitud de nueva funcionalidad
  QUESTION      // Pregunta general
  ACCOUNT       // Problema con la cuenta
  BILLING       // Problema de facturación
  PERFORMANCE   // Problema de rendimiento
  OTHER         // Otro
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN          // Recién creado
  IN_PROGRESS   // Un admin está trabajando en él
  WAITING_USER  // Esperando respuesta del usuario
  RESOLVED      // Resuelto (esperando confirmación)
  CLOSED        // Cerrado y confirmado
  CANCELLED     // Cancelado por el usuario
}

// ═══════════════════════════════════════════════════════════
// SISTEMA DE ALMACENAMIENTO (STORAGE)
// ═══════════════════════════════════════════════════════════

// Archivo almacenado
model StorageFile {
  id              String           @id @default(uuid())

  // Información del archivo
  filename        String
  originalName    String
  storagePath     String           // Ruta en el provider (key/path)
  storageProvider StorageProvider  @default(VERCEL_BLOB)
  mimeType        String
  size            BigInt           // Bytes
  checksum        String           // SHA-256 hash

  // Propietario y contexto
  userId          String
  folderId        String?          // Carpeta contenedora (opcional)

  // Control de acceso
  accessLevel     FileAccessLevel  @default(PRIVATE)
  usageContext    FileUsageContext @default(OTHER)

  // Seguridad
  encrypted       Boolean          @default(false)
  encryptionKeyId String?          // ID de la clave de encriptación

  // Procesamiento (para imágenes)
  isProcessed     Boolean          @default(false)
  processingStatus String?         // "pending", "processing", "completed", "failed"
  thumbnailPath   String?          // Ruta al thumbnail (si aplica)
  metadata        Json?            // EXIF, dimensiones, duración, etc.

  // Virus scanning
  virusScanStatus String?          // "pending", "clean", "infected", "error"
  virusScanDate   DateTime?

  // Relaciones
  folder          StorageFolder?   @relation(fields: [folderId], references: [id], onDelete: SetNull)
  accessLogs      FileAccessLog[]
  shares          FileShare[]

  // Auditoría
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?        // Soft delete
  expiresAt       DateTime?        // Para archivos temporales

  @@index([userId])
  @@index([folderId])
  @@index([usageContext])
  @@index([storageProvider])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("storage_files")
}

// Carpetas (organización jerárquica)
model StorageFolder {
  id          String          @id @default(uuid())
  userId      String

  name        String
  parentId    String?         // Para carpetas anidadas
  path        String          // Ruta completa (ej: "/docs/health")

  // Metadata
  description String?
  color       String?         // Para UI
  icon        String?         // Para UI

  // Relaciones
  parent      StorageFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    StorageFolder[] @relation("FolderHierarchy")
  files       StorageFile[]

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([userId, path])
  @@index([userId])
  @@index([parentId])
  @@map("storage_folders")
}

// Cuotas de almacenamiento por usuario
model StorageQuota {
  id              String   @id @default(uuid())
  userId          String   @unique

  // Límites
  maxStorage      BigInt   // Bytes totales permitidos
  maxFileSize     BigInt   // Tamaño máximo por archivo
  maxFiles        Int      // Número máximo de archivos

  // Uso actual
  usedStorage     BigInt   @default(0)
  fileCount       Int      @default(0)

  // Desglose por contexto
  usageBreakdown  Json?    // { "THEME": 1024, "AVATAR": 2048, ... }

  // Tier de suscripción (referencia)
  subscriptionTier String  @default("FREE")

  // Auditoría
  lastCalculated  DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@map("storage_quotas")
}

// Log de acceso a archivos (auditoría)
model FileAccessLog {
  id          String      @id @default(uuid())
  fileId      String
  userId      String

  action      FileAction  // "UPLOAD", "DOWNLOAD", "VIEW", "DELETE"
  ipAddress   String?
  userAgent   String?

  // Metadata adicional
  metadata    Json?       // Info extra dependiendo de la acción

  file        StorageFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  timestamp   DateTime    @default(now())

  @@index([fileId])
  @@index([userId])
  @@index([timestamp])
  @@map("file_access_logs")
}

// Sistema de compartición de archivos
model FileShare {
  id          String       @id @default(uuid())
  fileId      String
  sharedBy    String       // User ID

  // Tipo de compartición
  shareType   ShareType    @default(LINK)
  shareToken  String       @unique  // Token único para acceso vía link

  // Control de acceso
  password    String?      // Hash de contraseña (opcional)
  maxDownloads Int?        // Límite de descargas (null = ilimitado)
  downloadCount Int        @default(0)

  // Permisos
  allowDownload Boolean    @default(true)
  allowView     Boolean    @default(true)

  // Expiración
  expiresAt   DateTime?

  // Relaciones
  file        StorageFile  @relation(fields: [fileId], references: [id], onDelete: Cascade)

  // Auditoría
  createdAt   DateTime     @default(now())
  lastAccessed DateTime?
  revokedAt   DateTime?    // Para invalidar el share

  @@index([fileId])
  @@index([shareToken])
  @@index([expiresAt])
  @@map("file_shares")
}

// ═══════════════════════════════════════════════════════════
// ENUMS DEL STORAGE SYSTEM
// ═══════════════════════════════════════════════════════════

enum StorageProvider {
  VERCEL_BLOB   // Producción (default)
  LOCAL         // Desarrollo local
  AWS_S3        // AWS S3 (futuro)
  CLOUDFLARE_R2 // Cloudflare R2 (futuro)
}

enum FileAccessLevel {
  PRIVATE       // Solo el propietario
  INTERNAL      // Usuarios autenticados del sistema
  PUBLIC        // Acceso público (con link)
  SHARED        // Compartido con usuarios específicos
}

enum FileUsageContext {
  THEME         // Assets del tema (logos, favicon)
  AVATAR        // Avatares de usuarios
  TICKET        // Adjuntos de tickets de soporte
  ARTIFACT      // Artefactos generados por agentes
  HEALTH        // Documentos médicos (HIPAA)
  FINANCE       // Documentos financieros
  BACKUP        // Respaldos del sistema
  TEMP          // Archivos temporales
  OTHER         // Uso general
}

enum FileAction {
  UPLOAD
  DOWNLOAD
  VIEW
  DELETE
  SHARE
  UPDATE
}

enum ShareType {
  LINK          // Compartir vía link público
  EMAIL         // Compartir vía email (futuro)
  USER          // Compartir con usuario específico (futuro)
}

// ═══════════════════════════════════════════════════════════
// SISTEMA RAG (Phase 6 - Document Indexing)
// ═══════════════════════════════════════════════════════════

// Documento indexado para RAG (Retrieval-Augmented Generation)
model Document {
  id              String    @id @default(uuid())
  userId          String    // Owner del documento

  // Información del archivo
  filename        String
  originalName    String
  storageUrl      String    // URL en Vercel Blob
  mimeType        String
  size            BigInt    // Bytes

  // Procesamiento
  status          DocumentStatus @default(PENDING)
  processingError String?   @db.Text

  // Metadata de chunks
  totalChunks     Int       @default(0)
  chunkSize       Int       @default(800)    // Tokens por chunk
  chunkOverlap    Int       @default(200)    // Overlap entre chunks

  // Vectorización
  vectorIndexId   String?   // ID en Pinecone (namespace: userId)
  embeddingModel  String    @default("text-embedding-3-small")

  // Metadata de contenido
  contentType     DocumentContentType @default(GENERAL)
  language        String    @default("es")
  extractedText   String?   @db.Text  // Texto completo extraído (opcional)

  // Auditoría
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks          DocumentChunk[]

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime? // Soft delete

  @@index([userId])
  @@index([status])
  @@index([vectorIndexId])
  @@map("documents")
}

// Chunk de documento (fragmento indexado en Pinecone)
model DocumentChunk {
  id              String    @id @default(uuid())
  documentId      String

  // Contenido del chunk
  content         String    @db.Text
  chunkIndex      Int       // Orden en el documento (0, 1, 2, ...)
  tokens          Int       // Número de tokens

  // Vectorización
  vectorId        String?   // ID del vector en Pinecone
  embedding       String?   @db.Text  // Embedding serializado (opcional - cache)

  // Metadata adicional
  metadata        Json?     // Metadata extra (headers, page number, etc)

  // Relación
  document        Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  createdAt       DateTime  @default(now())

  @@unique([documentId, chunkIndex])
  @@index([documentId])
  @@index([vectorId])
  @@map("document_chunks")
}

// Estado del procesamiento del documento
enum DocumentStatus {
  PENDING           // Esperando procesamiento
  PROCESSING        // En procesamiento
  INDEXING          // Generando embeddings e indexando
  COMPLETED         // Completado exitosamente
  FAILED            // Error en procesamiento
  DELETED           // Soft delete
}

// Tipo de contenido del documento (para contexto)
enum DocumentContentType {
  GENERAL           // Documentación general
  TECHNICAL         // Documentación técnica
  MEDICAL           // Documentos médicos
  FINANCIAL         // Documentos financieros
  LEGAL             // Documentos legales
  EDUCATIONAL       // Material educativo
  PERSONAL          // Notas personales
  OTHER             // Otro tipo
}
